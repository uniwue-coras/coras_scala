type Annotation {
  endIndex: Int!
  errorType: ErrorType!
  id: Int!
  importance: AnnotationImportance!
  startIndex: Int!
  text: String!
}

enum AnnotationImportance {
  Less
  Medium
  More
}

input AnnotationInput {
  endIndex: Int!
  errorType: ErrorType!
  importance: AnnotationImportance!
  startIndex: Int!
  text: String!
}

enum Applicability {
  Applicable
  NotApplicable
  NotSpecified
}

enum CorrectionStatus {
  Finished
  Ongoing
  Waiting
}

enum ErrorType {
  Missing
  Wrong
}

type Exercise {
  id: Int!
  sampleSolution: [FlatSampleSolutionNode!]!
  text: String!
  title: String!
  userSolution(username: String!): UserSolution!
  userSolutions: [UserSolution!]!
}

input ExerciseInput {
  sampleSolution: [FlatSolutionNodeInput!]!
  text: String!
  title: String!
}

type ExerciseMutations {
  submitSolution(userSolution: UserSolutionInput!): Boolean!
  userSolution(username: String!): UserSolutionMutations!
}

type FlatSampleSolutionNode implements IFlatSolutionNode {
  applicability: Applicability!
  childIndex: Int!
  id: Int!
  isSubText: Boolean!
  parentId: Int
  text: String!
}

input FlatSolutionNodeInput {
  applicability: Applicability!
  childIndex: Int!
  id: Int!
  isSubText: Boolean!
  parentId: Int
  text: String!
}

type FlatUserSolutionNode implements IFlatSolutionNode {
  annotations: [Annotation!]!
  applicability: Applicability!
  childIndex: Int!
  id: Int!
  isSubText: Boolean!
  parentId: Int
  text: String!
}

interface IFlatSolutionNode {
  applicability: Applicability!
  childIndex: Int!
  id: Int!
  isSubText: Boolean!
  parentId: Int
  text: String!
}

enum MatchStatus {
  Automatic
  Deleted
  Manual
}

type Mutation {
  changePassword(oldPassword: String!, password: String!, passwordRepeat: String!): Boolean!
  claimJwt(ltiUuid: String!): String
  createExercise(exerciseInput: ExerciseInput!): Int!
  exerciseMutations(exerciseId: Int!): ExerciseMutations!
  login(password: String!, username: String!): String!
  register(password: String!, passwordRepeat: String!, username: String!): String!
}

type Query {
  exercise(exerciseId: Int!): Exercise!
  exercises: [Exercise!]!
  reviewCorrection(correctionReviewUuid: String!): ReviewData!
}

type ReviewData {
  matches: [SolutionNodeMatch!]!
  sampleSolution: [FlatSampleSolutionNode!]!
  userSolution: [FlatUserSolutionNode!]!
}

enum Rights {
  Admin
  Corrector
  Student
}

type SolutionNodeMatch {
  certainty: Float
  exerciseId: Int!
  matchStatus: MatchStatus!
  sampleValue: Int!
  userValue: Int!
  username: String!
}

type UserSolution {
  correctionStatus: CorrectionStatus!
  matches: [SolutionNodeMatch!]!
  nodes: [FlatUserSolutionNode!]!
  reviewUuid: String!
  username: String!
}

input UserSolutionInput {
  solution: [FlatSolutionNodeInput!]!
  username: String!
}

type UserSolutionMutations {
  finishCorrection: CorrectionStatus!
  initiateCorrection: CorrectionStatus!
  node(userSolutionNodeId: Int!): UserSolutionNode!
}

type UserSolutionNode {
  deleteAnnotation(annotationId: Int!): Int!
  deleteMatch(sampleSolutionNodeId: Int!): Boolean!
  submitMatch(sampleSolutionNodeId: Int!): SolutionNodeMatch!
  upsertAnnotation(annotation: AnnotationInput!, maybeAnnotationId: Int): Annotation!
}