type Annotation {
  endIndex: Int!
  exerciseId: Int!
  nodeId: Int!
  startIndex: Int!
  text: String!
  username: String!
}

input AnnotationInput {
  endIndex: Int!
  startIndex: Int!
  text: String!
}

enum Applicability {
  Applicable
  NotApplicable
  NotSpecified
}

type Exercise {
  allUsersWithCorrection: [String!]!
  allUsersWithSolution: [String!]!
  corrected: Boolean!
  flatCorrectionForUser(username: String!): [NodeIdMatch!]!
  flatSampleSolution: [FlatSolutionNode!]!
  flatUserSolution(username: String!): [FlatSolutionNode!]!
  id: Int!
  solutionSubmitted: Boolean!
  text: String!
  title: String!
}

type ExerciseMutations {
  submitCorrection(correctionInput: GraphQLCorrectionInput!): Boolean!
  submitSolution(userSolution: GraphQLUserSolutionInput!): Boolean!
  userSolutionNode(userSolutionNodeId: Int!, username: String!): UserSolutionNode
}

type ExtractedWord {
  index: Int!
  word: String!
}

type FlatSolutionNode {
  applicability: Applicability!
  childIndex: Int!
  id: Int!
  isSubText: Boolean!
  parentId: Int
  text: String!
}

input FlatSolutionNodeInput {
  applicability: Applicability!
  childIndex: Int!
  id: Int!
  isSubText: Boolean!
  parentId: Int
  text: String!
}

input GraphQLCorrectionInput {
  correctionAsJson: String!
  username: String!
}

input GraphQLExerciseInput {
  sampleSolution: [FlatSolutionNodeInput!]!
  text: String!
  title: String!
}

input GraphQLUserSolutionInput {
  maybeUsername: String
  solution: [FlatSolutionNodeInput!]!
}

type Match {
  sampleValue: ExtractedWord!
  userValue: ExtractedWord!
}

type Mutation {
  changePassword(oldPassword: String!, password: String!, passwordRepeat: String!): Boolean!
  claimJwt(ltiUuid: String!): String
  createExercise(exerciseInput: GraphQLExerciseInput!): Int!
  exerciseMutations(exerciseId: Int!): ExerciseMutations
  login(password: String!, username: String!): String!
  register(password: String!, passwordRepeat: String!, username: String!): String!
}

type NodeIdMatch {
  explanation: NounMatchingResult
  sampleValue: Int!
  userValue: Int!
}

type NounMatchingResult {
  matches: [Match!]!
  notMatchedSample: [ExtractedWord!]!
  notMatchedUser: [ExtractedWord!]!
}

type Query {
  exercise(exerciseId: Int!): Exercise!
  exercises: [Exercise!]!
}

enum Rights {
  Admin
  Corrector
  Student
}

type UserSolutionNode {
  submitAnnotation(annotation: AnnotationInput!): Annotation!
}